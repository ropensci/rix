# WARNING - Generated by {fusen} from dev/flat_with_nix.Rmd: do not edit by hand


#' Evaluate function in R or shell command via `nix-shell` environment
#' 
#' This function needs an installation of Nix. `with_nix()` has two effects
#' to run code in isolated and reproducible environments.
#' 1. Evaluate a function in R or a shell command via the `nix-shell`
#'   environment (Nix expression for custom software libraries; involving pinned
#'   versions of R and R packages via Nixpkgs)
#' 2. If no error, return the result object of `expr` in `with_nix()` into the
#'   current R session.
#'
#'
#' 
#' `with_nix()` gives you the power of evaluating a main function `expr` 
#' and its function call stack that are defined in the current R session
#' in an encapsulated nix-R session defined by Nix expression (`default.nix`),
#' which is located in at a distinct project path (`project_path`).
#' 
#' `with_nix()` is very convenient because it gives direct code feedback in 
#' read-eval-print-loop style, which gives a direct interface to the very 
#' reproducible infrastructure-as-code approach offered by Nix and Nixpkgs. You
#' don't need extra efforts such as setting up DevOps tooling like Docker and
#' domain specific tools like \{renv\} to control complex software environments in
#' R and any other language. It is for example useful for the following
#' purposes.
#' 
#' 1. test compatibility of custom R code and software/package dependencies in
#'   development and production environments
#' 2. directly stream outputs (returned objects), messages and errors from any
#'   command line tool offered in Nixpkgs into an R session.
#' 3. Test if evolving R packages change their behavior for given unchanged
#'   R code, and whether they give identical results or not.
#' 
#' `with_nix()` can evaluate both R code from a nix-R session within
#' another nix-R session, and also from a host R session (i.e., on macOS or
#' Linux) within a specific nix-R session. This feature is useful for testing
#' the reproducibility and compatibility of given code across different software
#' environments. If testing of different sets of environments is necessary, you
#' can easily do so by providing Nix expressions in custom `.nix` or
#' `default.nix` files in different subfolders of the project.
#' 
#' It is recommended that you use `rix_init()` to generate a custom `.Rprofile`
#' file for the subshell in `project_dir`. The defaults in that file ensure
#' that only R packages from the Nix store, that are defined in the subshell
#' `.nix` file are loaded and system's libraries are excluded.
#' 
#' 
#' To do its job, `with_nix()` heavily relies on patterns that manipulate
#' language expressions (aka computing on the language) offered in base R as
#' well as the \{codetools\} package by Luke Tierney.
#' 
#' Some of the key steps that are done behind the scene:
#' 1. recursively find, classify, and export global objects (globals) in the 
#' call stack of `expr` as well as propagate R package environments found.
#' 2. Serialize (save to disk) and deserialize (read from disk) dependent
#'  data structures as `.Rds` with necessary function arguments provided,
#'  any relevant globals in the call stack, packages, and `expr` outputs 
#'  returned in a temporary directory.
#' 3. Use pure `nix-shell` environments to execute a R code script 
#'   reconstructed catching expressions with quoting; it is launched by commands
#'  like this via `{sys}` by Jeroen Ooms:
#'  `nix-shell --pure --run "Rscript --vanilla"`.
#'
#' @param expr Single R function or call, or character vector of length one with
#' shell command and possibly options (flags) of the command to be invoked.
#' For `program = R`, you can both use a named or an anonymous function. 
#' The function provided in `expr` should not evaluate when you pass arguments,
#' hence you need to wrap your function call like
#' `function() your_fun(arg_a = "a", arg_b = "b")`, to avoid evaluation and make
#' sure `expr` is a function (see details and examples).
#' @param program String stating where to evaluate the expression. Either `"R"`,
#' the default, or `"shell"`. `where = "R"` will evaluate the expression via
#' `RScript` and `where = "shell"` will run the system command in `nix-shell`.
#' @param exec_mode Either `"blocking"` (default) or `"non-blocking`. This
#' will either block the R session while `expr` is running in a `nix-shell`
#' environment, oor running it in the background ("non-blocking"). While
#' `program = R` will yield identical results for foreground and background
#' evaluation (R object), `program = "shell"` will return list of exit status,
#' standard output and standard error of the system command and as text in
#' blocking mode.
#' @param project_path Path to the folder where the `default.nix` file resides. 
#' The default is `"."`, which is the working directory in the current R
#' session. This approach also useful when you have different subfolders 
#' with separate software environments defined in different `default.nix` files.
#' If you prefer to run code in custom `.nix` files in the same directory
#' using `with_nix()`, you can use the `nix_file` argument to specify paths
#' to `.nix` files.
#' @param nix_file Path to `.nix` file that contains the expressions defining
#' the Nix software environment in which you want to run `expr`. See
#'  `project_path` argument as an alternative way to specify the environment.
#' @param message_type String how detailed output is. Currently, there is 
#' either `"simple"` (default) or `"verbose"`, which shows the script that runs
#' via `nix-shell`.
#' @importFrom codetools findGlobals checkUsage
#' @export
#' @return 
#' - if `program = "R"`, R object returned by function given in `expr`
#' when evaluated via the R environment in `nix-shell` defined by Nix 
#' expression.
#' - if `program = "shell"`, list with the following elements:
#'     - `status`: exit code
#'     - `stdout`: character vector with standard output
#'     - `stderr`: character vector with standard error
#' of `expr` command sent to a command line interface provided by a Nix package.
#' @examples
#' \dontrun{
#' # create an isolated, runtime-pure R setup via Nix
#' project_path <- "./sub_shell"
#' rix_init(
#'   project_path = project_path,
#'   rprofile_action = "create_missing"
#' )
#' # generate nix environment in `default.nix`
#' rix(
#'   r_ver = "4.2.0",
#'   project_path = project_path
#' )
#' # evaluate function in Nix-R environment via `nix-shell` and `Rscript`,
#' # stream messages, and bring output back to current R session
#' out <- with_nix(
#'   expr = function(mtcars) nrow(mtcars),
#'   program = "R", exec_mode = "non-blocking", project_path = project_path,
#'   message_type = "simple"
#' )
#' 
#' # There no limit in the complexity of function call stacks that `with_nix()`
#' # can possibly handle; however, `expr` should not evaluate and 
#' # needs to be a function for `program = "R"`. If you want to pass the
#' # a function with arguments, you can do like this
#' get_sample <- function(seed, n) {
#'   set.seed(seed)
#'   out <- sample(seq(1, 10), n)
#'   return(out)
#' }
#' 
#' out <- with_nix(
#'   expr = get_sample(seed = 1234, n = 5),
#'   program = "R", exec_mode = "non-blocking",
#'   project_path = ".",
#'   message_type = "simple"
#' )
#' 
#' ## You can also attach packages with `library()` calls in the current R 
#' ## session, which will be exported to the nix-R session.
#' ## Other option: running system commands through `nix-shell` environment.
#' }
with_nix <- function(expr,
                     program = c("R", "shell"),
                     exec_mode = c("blocking", "non-blocking"),
                     project_path = ".",
                     nix_file = NULL,
                     message_type = c("simple", "verbose")) {
  if (is.null(nix_file)) {
    nix_file <- file.path(project_path, "default.nix")
  }
  stopifnot(
    "`project_path` must be character of length 1." =
      is.character(project_path) && length(project_path) == 1L,
    "`project_path` has no `default.nix` file. Use one that contains `default.nix`" =
      file.exists(nix_file),
    "`message_type` must be character." = is.character(message_type),
    "`expr` needs to be a call or function for `program = R`, and character of length 1 for `program = shell`" =
      is.function(expr) || is.call(expr) || (is.character(expr) && length(expr) == 1L)
  )
  
  # ad-hoc solution for RStudio's limitation that R sessions cannot yet inherit
  # proper `PATH` from custom `.Rprofile` on macOS (2023-01-17)
  # adjust `PATH` to include `/nix/var/nix/profiles/default/bin`
  if (isTRUE(is_rstudio_session()) && isFALSE(is_nix_rsession())) {
    set_nix_path()
  }
  
  if (isTRUE(nzchar(Sys.getenv("NIX_STORE")))) {
    # for Nix R sessions, guarantee that the system's user library 
    # (R_LIBS_USER) is not in the search path for packages => run-time purity
    current_libpaths <- .libPaths()
    # don't do this in covr test environment, because this sets R_LIBS_USER
    # to multiple paths
    R_LIBS_USER <- Sys.getenv("R_LIBS_USER")
    if (isFALSE(nzchar(Sys.getenv("R_COVR")))) {
      remove_r_libs_user()
    }
  } else {
    LD_LIBRARY_PATH_default <- Sys.getenv("LD_LIBRARY_PATH")
    if (nzchar(LD_LIBRARY_PATH_default)) {
      # On some systems, like Ubuntu 22.04, we found that a preset 
      # `LD_LIBRARY_PATH` environment variable in the system's R session
      # (R installed via apt) is responsible for causing  a segmentation fault
      # for both `nix-build` and `nix-shell` when invoked via 
      # `sys::exec_internal`, `base::system()` or `base::system2()` from R.
      # This seems due to incompatible linked libraries or permission issue that
      # conflict when mixing Nix packages and libraries from the system.
      # Therefore, we set it to `""` and set  back the default (old)
      # `LD_LIBRARY_PATH` when `with_nix()` exits. For newer RStudio versions,
      # LD_LIBRARY_PATH is not `""` anymore
      # https://github.com/rstudio/rstudio/issues/12585
      fix_ld_library_path()
      cat("* Current LD_LIBRARY_PATH in system R session is:",
        LD_LIBRARY_PATH_default)
      cat("\n", "Setting `LD_LIBRARY_PATH` to `''` during `nix_build()`")
    }
  }
  
  has_nix_shell <- nix_shell_available() # TRUE if yes, FALSE if no
  
  if (isFALSE(has_nix_shell)) {
    stop(
      paste0("`nix-shell` is needed but is not available in your current ",
        "shell environment.\n",
        "* If you are in an R session of your host operating system, you
        either\n1a) need to install Nix first, or if you have already done so ",
        "\n",
        "To install, we suggest you follow https://zero-to-nix.com/start/install .",
        "\n",
        "1b) make sure that the location of the nix store is in the `PATH`
        variable of this R session (mostly necessary in RStudio).\n",
        "* If you ran `with_nix()` from R launched in a `nix-shell`, you need
        to make sure that `pkgs.nix` is in the `buildInput` for ",
        "`pkgs.mkShell`.\nIf you used `rix::rix()` to generate your main nix
        configuration of this session, just regenerate it with the additonal
        argument `system_pkgs = 'nix'."),
      call. = FALSE
    )
  }
  
  program <- match.arg(program)
  exec_mode <- match.arg(exec_mode)
  message_type <- match.arg(message_type)
  
  if (program == "R") {
  
    # get the function arguments as a pairlist;
    # save formal arguments of pairlist via `tag = value`; e.g., if we have a
    # `expr = function(p = p_root) dir(path = p)`, the input object
    # to be serialized will be serialized under `"p.Rds"`  in a tmp dir, and
    # will contain object `p_root`, which is defined in the global environment
    # and bound to `"."` (project root)
    args <- as.list(formals(expr))
    
    cat("\n### Prepare to exchange arguments and globals for `expr`",
      "between the host and Nix R sessions ###\n")
    
    # 1) save all function args onto a temporary folder each with
    # `<tag.Rds>` and `value` as serialized objects from RAM ---------------------
    temp_dir <- file.path(tempdir(), "with_nix")
    if (!dir.exists(temp_dir)) {
      dir.create(temp_dir)
    }
    serialize_args(args, temp_dir)
    
    # cast list of symbols/names and calls to list of strings; this is to prepare
    # deparsed version (string) of deserializing arguments from disk;
    # elements of args for now should be of type "symbol" or "language"
    args_vec <- vapply(args, deparse, FUN.VALUE = character(1L))
    
    # todo in `rnix_deparsed`:
    # => locate all global variables used by function
    # https://github.com/cran/codetools/blob/master/R/codetools.R
    # http://adv-r.had.co.nz/Expressions.html#ast-funs
    
    # code inspection: generates messages with potential problems
    check_expr(expr)
    
    globals_expr <- recurse_find_check_globals(expr, args_vec)
    
    # wrapper around `serialize_lobjs()`
    globals <- serialize_globals(globals_expr, temp_dir)
    
    # extract additional packages to export
    pkgs <- serialize_pkgs(globals_expr, temp_dir)
    
    # 2) deserialize formal arguments of `expr` in nix session
    # and necessary global objects ---------------------------------------------
    # 3) serialize resulting output from evaluating function given as `expr`
    
    # main code to be run in nix R session
    rnix_file <- file.path(temp_dir, "with_nix_r.R")
    
    rnix_quoted <- quote_rnix(
      expr, program, message_type, args_vec, globals, pkgs, temp_dir, rnix_file
    )
    rnix_deparsed <- deparse_chr1(expr = rnix_quoted, collapse = "\n")
    
    # 4): for 2) and 3) write script to disk, to run later via `Rscript` from
    # `nix-shell` 
    # environment
    r_version_file <- file.path(temp_dir, "nix-r-version.txt")
    writeLines(text = rnix_deparsed, file(rnix_file))
    
    # 3) run expression in nix session, based on temporary script
    cat(paste0("==> Running deparsed expression via `nix-shell`", " in ",
      exec_mode, " mode:\n\n"#,
      # paste0(rnix_deparsed, collapse = " ")
    ))

    # command to run deparsed R expression via nix-shell
    cmd_rnix_deparsed <- c(
      file.path(project_path, "default.nix"),
      "--pure", # required for to have nix glibc
      "--run",
      sprintf(
        "Rscript --no-site-file --no-environ --no-restore '%s'",
        rnix_file
      )
    )
    
    proc <- switch(exec_mode,
      "blocking" = sys::exec_internal(cmd = "nix-shell", cmd_rnix_deparsed),
      "non-blocking" = sys::exec_background(
        cmd = "nix-shell", cmd_rnix_deparsed),
      stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
    )
    if (exec_mode == "non-blocking") {
      poll_sys_proc_nonblocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
    } else if (exec_mode == "blocking") {
      poll_sys_proc_blocking(cmd = cmd_rnix_deparsed, proc, what = "expr")
    }
  } else if (program == "shell") { # end of `if (program == "R")`
    shell_cmd <- c(
      file.path(project_path, "default.nix"),
      "--pure",
      "--run",
      expr
    )
    proc <- switch(exec_mode,
      "blocking" = sys::exec_internal(cmd = "nix-shell", shell_cmd),
      "non-blocking" = sys::exec_background(
        cmd = "nix-shell", shell_cmd),
      stop('invalid `exec_mode`. Either use "blocking" or "non-blocking"')
    )
  }
  
  # 5) deserialize final output of `expr` evaluated in nix-shell
  # into host R session
  if (program == "R") {
    out <- readRDS(file = file.path(temp_dir, "_out.Rds"))
  } else if (program == "shell") {
    if (exec_mode == "non-blocking") {
      status <- poll_sys_proc_nonblocking(
        cmd = shell_cmd, proc, what = "expr"
      )
      out <- status
    } else if (exec_mode == "blocking") {
      poll_sys_proc_blocking(cmd = shell_cmd, proc, what = "expr")
      out <- proc
      out$stdout <- sys::as_text(out$stdout)
      out$stderr <- sys::as_text(out$stderr)
    }
  }

  cat("\n### Finished code evaluation in `nix-shell` ###\n")
  
  if (isTRUE(nzchar(Sys.getenv("NIX_STORE")))) {
    # set back library paths to state before calling `with_nix()`
     .libPaths(current_libpaths)
  } else {
    if (nzchar(LD_LIBRARY_PATH_default)) {
      # set old LD_LIBRARY_PATH (only if system's R session and if it wasn't
      # `""`)
      on.exit(Sys.setenv(LD_LIBRARY_PATH=LD_LIBRARY_PATH_default))
    }
  }
  
  # return output from evaluated function
  cat("\n* Evaluating `expr` in `nix-shell` returns:\n")
  if (program == "R") {
    print(out)
  } else if (program == "shell") {
    print(out$stdout)
  }
  cat("")
  
  on.exit(unlink(temp_dir, recursive = TRUE, force = TRUE), after = FALSE)
  
  return(out)
}


#' serialize language objects
#' @noRd
serialize_lobjs <- function(lobjs, temp_dir) {
  invisible({
    for (i in seq_along(lobjs)) {
      if (!any(nzchar(deparse(lobjs[[i]])))) {
        # for unnamed arguments like `expr = function(x) print(x)`
        # x would be an empty symbol, see also ; i.e. arguments without 
        # default expressions; i.e. tagged arguments with no value
        # https://stackoverflow.com/questions/3892580/create-missing-objects-aka-empty-symbols-empty-objects-needed-for-f
        lobjs[[i]] <- as.symbol(names(lobjs)[i])
      }
      saveRDS(
        object = lobjs[[i]],
        file = file.path(temp_dir, paste0(names(lobjs)[i], ".Rds"))
      )
    }
  })
}

serialize_args <- function(args, temp_dir) {
  invisible({
    for (i in seq_along(args)) {
      if (!nzchar(deparse(args[[i]]))) {
        # for unnamed arguments like `expr = function(x) print(x)`
        # x would be an empty symbol, see also ; i.e. arguments without 
        # default expressions; i.e., tagged arguments with no value
        # https://stackoverflow.com/questions/3892580/create-missing-objects-aka-empty-symbols-empty-objects-needed-for-f
        args[[i]] <- as.symbol(names(args)[i])
      }
      args[[i]] <- get(as.character(args[[i]]))
      saveRDS(
        object = args[[i]],
        file = file.path(temp_dir, paste0(names(args)[i], ".Rds"))
      )
    }
  })
}


#' @noRd
check_expr <- function(expr) {
    cat("* checking code in `expr` for potential problems:\n",
      "`codetools::checkUsage(fun = expr)`\n")
    codetools::checkUsage(fun = expr)
    cat("\n")
  }


#' @noRd
# to determine which extra packages to load in Nix R prior evaluating `expr`
get_expr_extra_pkgs <- function(globals_expr) {
  envs_check <- lapply(globals_expr, where)
  names_envs_check <- vapply(envs_check, environmentName, character(1L))
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  pkgenvs_attached <- setdiff(
     grep("^package:", names_envs_check, value = TRUE), 
    c(default_pkgnames, "base")
  )
  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
    return(pkgs_to_attach)
  } else {
    return(NULL)
  }
}


#' @noRd
is_empty <- function(x) identical(x, emptyenv())


#' @noRd
where <- function(name, env = parent.frame()) {
  while(!is_empty(env)) {
    if (exists(name, envir = env, inherits = FALSE)) {
      return(env)
    }
    # inspect parent
    env <- parent.env(env)
  }
}

#' Finds and checks global functions and variables recursively for closure
#' `expr`
#' @noRd
recurse_find_check_globals <- function(expr, args_vec) {
    
    cat("* checking code in `expr` for potential problems:\n")
    codetools::checkUsage(fun = expr)
    cat("\n")
    
    globals_expr <- codetools::findGlobals(fun = expr)
    globals_lst <- classify_globals(globals_expr, args_vec)
    
    round_i <- 1L
      
    repeat {
      
      get_globals_exprs <- function(globals_lst) {
        globals_exprs <- names(unlist(Filter(function(x) !is.null(x), 
          unname(globals_lst[c("globalenv_fun", "env_fun")]))))
        return(globals_exprs)
      }
      
      if (round_i == 1L) {
        # first round
        globals_exprs <- get_globals_exprs(globals_lst)
      } else {
        # successive rounds
        globals_exprs <- unlist(lapply(globals_lst, get_globals_exprs))
      }
      
      cat("* checking code in `globals_exprs` for potential problems:\n")
      lapply(
        globals_exprs,
        codetools::checkUsage
      )
      cat("\n")
    
      globals_new <- lapply(
        globals_exprs,
        function(x) codetools::findGlobals(fun = x)
      )
      
      globals_lst_new <- lapply(
        globals_new,
        function(x) classify_globals(globals_expr = x, args_vec)
      )
      
      if (round_i == 1L) {
        result_list <- c(list(globals_lst), globals_lst_new)
      } else {
        result_list <- c(result_list, globals_lst_new)
      }
      
      # prepare current globals to find new globals one recursion level deeper
      # in the call stack in the next repeat
      globals_lst <- globals_lst_new
      
      globals_lst <- lapply(globals_lst, function(x) lapply(x, unlist))
      
      # packages need to be excluded for getting more globals
      globals_lst <- lapply(
        globals_lst,
        function(x) {
          x[c("globalenv_fun", "globalenv_other", "env_other", "env_fun")]
        }
      )
      
      globals_null <- all(is.null(unlist(globals_lst)))
      # TRUE if no more candidate global values
      all_non_pkgs_null <- all(globals_null)
      
      round_i <- round_i + 1L
      
      if (is.null(globals_lst) || all_non_pkgs_null) break
    }
  
    result_list <- Filter(function(x) !is.null(x), result_list)
    result_list <- lapply(
      result_list, 
      function(x) Filter(function(x) !is.null(x), x)
    )
    
    pkgs <- unlist(lapply(result_list, "[", "pkgs"))
    
    unlist_unname <- function(x) {
      unlist(
        lapply(x,  function(x) unlist(unname(x)))
      )
    }
    
    globalenv_fun <- lapply(result_list, "[", "globalenv_fun")
    globalenv_fun <- unlist_unname(globalenv_fun)
    
    globalenv_other <- lapply(result_list, "[", "globalenv_other")
    globalenv_other <- unlist_unname(globalenv_other)
    
    env_other <- lapply(result_list, "[", "env_other")
    env_other <- unlist_unname(env_other)
    
    env_fun <- lapply(result_list, "[", "env_fun")
    env_fun <- unlist_unname(env_fun)
    
    exports <- list(
      pkgs = pkgs,
      globalenv_fun = globalenv_fun,
      globalenv_other = globalenv_other,
      env_other = env_other,
      env_fun = env_fun
    )
    
    return(exports)
}

#' @noRd
classify_globals <- function(globals_expr, args_vec) {
  envs_check <- lapply(globals_expr, where)
  names(envs_check) <- globals_expr
  
  vec_envs_check <- vapply(envs_check, environmentName, character(1L))
  # directly remove formals
  vec_envs_check <- vec_envs_check[!names(vec_envs_check) %in% args_vec]
  if (length(vec_envs_check) == 0L) {
    vec_envs_check <- NULL
  }
  
  if (!is.null(vec_envs_check)) {
    globs_pkg <- grep("^package:", vec_envs_check, value = TRUE)
    if (length(globs_pkg) == 0L) {
      globs_pkg <- NULL
    }
    # globs base can be ignored
    globs_base <- grep("^base$", vec_envs_check, value = TRUE)
    globs_globalenv <- grep("^R_GlobalEnv$", vec_envs_check, value = TRUE)
    globs_globalenv <- Filter(nzchar, globs_globalenv)
    # empty globs; can be ignored for now
    globs_empty <- Filter(function(x) !nzchar(x), vec_envs_check)
    if (length(globs_empty) == 0L) {
      globs_empty <- NULL
    }
    globs_other <- vec_envs_check[!names(vec_envs_check) %in% 
      names(c(globs_pkg, globs_globalenv, globs_empty, globs_base))]
    if (length(globs_other) == 0L) {
      globs_other <- NULL
    }
  }
  
  is_globalenv_funs <- vapply(
    names(globs_globalenv), function(x) is.function(get(x)),
    FUN.VALUE = logical(1L)
  )
  
  is_otherenv_funs <- vapply(
    names(globs_other), function(x) is.function(get(x)),
    FUN.VALUE = logical(1L)
  )
  
  globs_globalenv_fun <- globs_globalenv[is_globalenv_funs]
  if (length(globs_globalenv_fun) == 0L) {
    globs_globalenv_fun <- NULL
  }
  globs_globalenv_other <- globs_globalenv[!is_globalenv_funs]
  if (length(globs_globalenv_other) == 0L) {
    globs_globalenv_other <- NULL
  }
  
  globs_otherenv_fun <- globs_other[is_otherenv_funs]
  if (length(globs_otherenv_fun) == 0L) {
    globs_otherenv_fun <- NULL
  }
  globs_otherenv_other <- globs_other[!is_otherenv_funs]
  if (length(globs_otherenv_other) == 0L) {
    globs_otherenv_other <- NULL
  }
  
  default_pkgnames <- paste0("package:", getOption("defaultPackages"))
  pkgenvs_attached <- setdiff(globs_pkg, c(default_pkgnames, "base"))

  if (!length(pkgenvs_attached) == 0L) {
    pkgs_to_attach <- gsub("^package:", "", pkgenvs_attached)
  } else {
    pkgs_to_attach <- NULL
  }
  
  globs_classified <- list(
    globalenv_fun = globs_globalenv_fun,
    globalenv_other = globs_globalenv_other,
    env_other = globs_otherenv_other,
    env_fun = globs_otherenv_fun,
    pkgs = pkgs_to_attach
  )
  globs_null <- all(vapply(globs_classified, is.null, logical(1L)))
  if (globs_null) globs_classified <- NULL
  
  return(globs_classified)
}


# wrapper to serialize expressions of all global objects found
#' @noRd
serialize_globals <- function(globals_expr, temp_dir) {
  funs <- globals_expr$globalenv_fun
  if (!is.null(funs)) {
    cat("=> Saving global functions to disk:", paste(names(funs)), "\n")
    globalenv_funs <- lapply(
      names(funs),
      function(x) get(x = x, envir = .GlobalEnv)
    )
    names(globalenv_funs) <- names(globals_expr$globalenv_fun)
    serialize_lobjs(lobjs = globalenv_funs, temp_dir)
  }
  others <- globals_expr$globalenv_other
  if (!is.null(others)) {
    cat("=> Saving non-function object(s), e.g. other environments:",
      paste(names(others)), "\n"
    )
    globalenv_others <- lapply(
      names(others),
      function(x) get(x = x, envir = .GlobalEnv)
    )
    names(globalenv_others) <- names(globals_expr$globalenv_other)
    serialize_lobjs(lobjs = globalenv_others, temp_dir)
  }
  env_funs <- globals_expr$env_fun
  if (!is.null(env_funs)) {
    cat("=> Serializing function(s) from other environment(s):",
      paste(names(env_funs)), "\n")
    env_funs <- lapply(
      names(env_funs),
      function(x) get(x = x)
    )
    names(env_funs) <- names(globals_expr$env_fun)
    serialize_lobjs(lobjs = env_funs, temp_dir)
  }
  env_others <- globals_expr$env_other
  if (!is.null(env_others)) {
    cat("=> Serializing non-function object(s) from custom environment(s)::",
      paste(names(env_others)), "\n"
    )
    env_others <- lapply(
      names(env_others),
      function(x) get(x = x)
    )
    names(env_others) <- names(globals_expr$env_other)
    serialize_lobjs(lobjs = env_others, temp_dir)
  }
  
  return(c(funs, others, env_funs, env_others))
}


#' @noRd
serialize_pkgs <- function(globals_expr, temp_dir) {
  pkgs <- globals_expr$pkgs
  if (!is.null(pkgs)) {
    cat("=> Serializing package(s) required to run `expr`:\n",
      paste(pkgs), "\n"
    )
  }
  saveRDS(
    object = pkgs,
    file = file.path(temp_dir, "_pkgs.Rds")
  )
  return(pkgs)
}

# build deparsed script via language objects;
# reads like R code, and avoids code injection
quote_rnix <- function(expr,
                       program,
                       message_type,
                       args_vec,
                       globals,
                       pkgs,
                       temp_dir,
                       rnix_file) {
  expr_quoted <- bquote( {
    cat("### Start evaluating `expr` in `nix-shell` ###")
    cat("\n* wrote R script evaluated via `Rscript` in `nix-shell`:",
      .(rnix_file))
    temp_dir <- .(temp_dir)
    cat("\n", Sys.getenv("NIX_PATH"))
    # fix library paths for nix R on macOS and linux; avoid permission issue
    current_paths <- .libPaths()
    userlib_paths <- Sys.getenv("R_LIBS_USER")
    user_dir <- grep(paste(userlib_paths, collapse = "|"), current_paths)
    new_paths <- current_paths[-user_dir]
    .libPaths(new_paths)
    r_version_num <- paste0(R.version$major, ".", R.version$minor)
    cat("\n* using Nix with R version", r_version_num, "\n\n")
    # assign `args_vec` as in c(...) form.
    args_vec <- .(with_assign_vecnames_call(vec = args_vec))
    # deserialize arguments from disk
    for (i in seq_along(args_vec)) {
      nm <- args_vec[i]
      obj <- args_vec[i]
      assign(
        x = nm,
        value = readRDS(file = file.path(temp_dir, paste0(obj, ".Rds")))
      )
      cat(
        paste0("  => reading file ", "'", obj, ".Rds", "'",
          " for argument named `", obj, "`\n")
      )
    }

    globals <- .(with_assign_vecnames_call(vec = globals))
    for (i in seq_along(globals)) {
      nm <- globals[i]
      obj <- globals[i]
      assign(
        x = nm,
        value = readRDS(file = file.path(temp_dir, paste0(obj, ".Rds")))
      )
      cat(
        paste0("  => reading file ", "'", obj, ".Rds", "'",
          " for global object named `", obj, "`\n")
      )
    }

    # for now name of character vector containing packages is hard-coded
    # pkgs <- .(with_assign_vecnames_call(vec = pkgs))
    # pkgs <- .(pkgs)
    pkgs <- .(with_assign_vec_call(vec = pkgs))
    lapply(pkgs, library, character.only = TRUE)

    # execute function call in `expr` with list of correct args
    lst <- as.list(args_vec)
    names(lst) <- args_vec
    lst <- lapply(lst, as.name)
    rnix_out <- do.call(.(expr), lst)
    cat("\n* called `expr` with args", args_vec, ":\n")
    message_type <- .(message_type)
    if (message_type == "verbose") {
    # cat("\n", deparse(.(expr))) # not nicely formatted, use print
      # print(.(expr))
    }
    cat("\n* The type of the output object returned by `expr` is",
      typeof(rnix_out))
    saveRDS(object = rnix_out, file = file.path(temp_dir, "_out.Rds"))
    cat("\n* Saved output to", file.path(temp_dir, "_out.Rds"))
    cat("\n\n* the following objects are in the global environment:\n")
    cat(ls())
    cat("\n")
    cat("\n* `sessionInfo()` output:\n")
    try(cat(capture.output(sessionInfo()), sep = "\n"))
  } ) # end of `bquote()`

  return(expr_quoted)
}

# https://github.com/cran/codetools/blob/master/R/codetools.R
# finding global variables

# reconstruct argument vector (character) in Nix R;
# build call to generate `args_vec`
#' @noRd
with_assign_vecnames_call <- function(vec) {
  cl <- call("c")
  for (i in seq_along(vec)) {
    cl[[i + 1L]] <- names(vec[i])
  }
  return(cl)
}

#' @noRd
with_assign_vec_call <- function(vec) {
  cl <- call("c")
  for (i in seq_along(vec)) {
    cl[[i + 1L]] <- vec[i]
  }
  return(cl)
}

# this is what `deparse1()` does, however, it is only since 4.0.0
#' @noRd
deparse_chr1 <- function(expr, width.cutoff = 500L, collapse = " ", ...) {
  paste(deparse(expr, width.cutoff, ...), collapse = collapse)
}

#' @noRd
with_expr_deparse <- function(expr) {
  sprintf(
    'run_expr <- %s\n',
    deparse_chr1(expr = expr, collapse = "\n")
  )
}

#' @noRd
nix_shell_available <- function() {
  which_nix_shell <- Sys.which("nix-shell")
  if (nzchar(which_nix_shell)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

#' @noRd
create_shell_nix <- function(path = file.path("inst", "extdata", 
                              "with_nix", "default.nix")) {
  if (!dir.exists(dirname(path))) {
    dir.create(dirname(path), recursive = TRUE)
  }

  rix(
    r_ver = "latest",
    r_pkgs = NULL,
    system_pkgs = NULL,
    git_pkgs = NULL,
    ide = "other",
    project_path = dirname(path),
    overwrite = TRUE,
    shell_hook = NULL
  )
}
