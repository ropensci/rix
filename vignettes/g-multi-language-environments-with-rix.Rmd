---
title: "g - Developing packages with rix environments"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{g-developing-packages-with-rix-environments}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include=FALSE}
library(rix)
```

## Why bring `{rix}` into your package workflow?

`{rix}` was built to make it effortless to describe the full set of
runtime requirements that an R project depends on. For package
developers, this means you can capture every CRAN package, system
library, and tool that the project needs into a single `default.nix`
file. Checking that file into source control keeps the development
experience consistent across contributors, continuous integration (CI)
jobs, and release automation.

This vignette walks through a recommended development loop for package
authors:

1. Declare the package dependencies with `{rix}`.
2. Commit the resulting `default.nix` to the repository.
3. Use the same definition locally and in CI/CD (for example GitHub
   Actions).
4. Refresh the snapshot frequently so that you notice upstream changes
   early.

## Declaring your package environment

Start by calling `rix()` from your package root. List the R packages and
system tools that your package requires for development, testing, or
vignette builds. A recent snapshot date ensures that you exercise the
code against current CRAN releases.

```{r, eval = FALSE}
rix(
  r_ver = "bleeding-edge",
  r_pkgs = c(
    "devtools", "rcmdcheck", "roxygen2", # package development helpers
    "jsonlite", "httr"                    # package runtime deps
  ),
  system_pkgs = c("pandoc", "pkg-config"),
  ide = "code",
  date = "2024-03-15",
  path = "default.nix",
  overwrite = TRUE
)
```

A few tips when shaping the environment:

- Prefer `r_ver = "bleeding-edge"` (or at least a very recent
  release). This aligns your local setup with what users will experience
  soon and surfaces compatibility problems early.
- Keep `date` current. Updating it every few weeks lets you track CRAN,
  nixpkgs, and system toolchain updates. If the new snapshot fails you
  can fix issues right away instead of facing a large backlog later.
- Include command line tools that power your package (such as `pandoc`
  for vignettes or `quarto`, `rustc`, etc.). `{rix}` will fetch matching
  builds for the pinned snapshot.

## Committing the environment to your repository

The generated `default.nix` is deterministic and can be committed like
any other source file. Place it at the root of the package repository so
that contributors can run:

```sh
nix develop
```

This drops them into a shell with all declared dependencies available.
Within that shell you can run commands such as `R CMD build`,
`rcmdcheck::rcmdcheck()`, or your preferred test runners and scripts.

To simplify onboarding, document in `README.md` (or a contributing guide)
that contributors should run `nix develop` before working on the
package. This also makes it easy to script common tasks, for example
running lint checks:

```{r, eval = FALSE}
with_nix(
  expr = quote(rcmdcheck::rcmdcheck(args = c("--no-manual"))),
  path = "default.nix"
)
```

Because the environment is pinned, collaborators and CI jobs execute the
same versions of your dependencies, eliminating “works on my machine”
bugs.

## Keeping the snapshot fresh

Re-run `rix()` with an updated `date` (and `r_ver` when appropriate)
at a regular cadence. Many teams do this monthly or when preparing a new
release. The workflow can be as simple as:

```{r, eval = FALSE}
rix(
  r_ver = "bleeding-edge",
  r_pkgs = c("devtools", "rcmdcheck", "roxygen2", "jsonlite", "httr"),
  system_pkgs = c("pandoc", "pkg-config"),
  date = as.character(Sys.Date()),
  path = "default.nix",
  overwrite = TRUE
)
```

Commit the refreshed `default.nix` and run your test suite. If the build
fails you can immediately address incompatibilities introduced by recent
CRAN or system package changes.

For larger projects you can automate this check: schedule a weekly or
monthly job (either locally or in CI) that updates the date, rebuilds
the environment, and runs your package’s validation pipeline.

## Using `{rix}` in GitHub Actions

Because `default.nix` captures the entire toolchain, you can use it as
the basis for your CI workflow. A minimal GitHub Actions configuration
that exercises `rcmdcheck` inside the environment might look like:

```yaml
name: R CMD check

on:
  push:
    branches: [main]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Nix
        uses: cachix/install-nix-action@v27
      - name: Build development shell
        run: nix develop --command true
      - name: Run checks inside the shell
        run: nix develop --command Rscript -e "rcmdcheck::rcmdcheck(args = c('--no-manual'))"
```

The workflow builds the same shell you use locally and reuses Nix’s
binary cache for fast, reproducible builds. Any failure signals that
newly published CRAN or system packages interact poorly with your code,
allowing you to fix issues before they reach users.

## Summary

By defining your package environment with `{rix}`, committing the
`default.nix`, and reusing it across local development and CI/CD, you
build confidence that your package remains compatible with the evolving
R ecosystem. Regularly updating the snapshot keeps you close to the
latest CRAN state while still benefiting from the reproducibility that
Nix provides.
