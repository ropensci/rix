---
kind: context_header
llm_instructions: This is an LLM-optimized API specification for the R package 'rix'. Use this context to write correct code using rix functions. Each 'function' record describes a public function with its signature, arguments, and purpose. The 'package' record contains metadata. All listed functions are part of the public API.
---
kind: package
schema_version: '1.1'
name: rix
version: 0.17.4
language: R
description: Reproducible Data Science Environments with 'Nix'
---
kind: function
name: renv2nix
exported: true
signature: renv2nix(renv_lock_path = "renv.lock",project_path,return_rix_call = FALSE,method = c("fast", "accurate"),override_r_ver = NULL,...)
arguments:
  '...': 'Arguments passed on to \link[=rix]{rix} Vector of characters. List further software you wish to install that are not R packages such as command line applications for example. You can look for available software on the NixOS website https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query= Vector of characters, paths to local packages to install. These packages need to be in the .tar.gz or .zip formats and must be in the same folder as the generated "default.nix" file. Vector of characters. A set of TeX packages to install. Use this if you need to compile .tex documents, or build PDF documents using Quarto. If you don''t know which package to add, start by adding "amsmath". See the vignette("d2- installing-system-tools-and-texlive-packages-in-a-nix-environment") for more details. List. A list containing two or three elements: py_version, py_pkgs, and optionally py_src_dir. py_version should be in the form "3.12" for Python 3.12, and py_pkgs should be an atomic vector of package names (e.g., py_pkgs = c("polars", "plotnine", "great-tables")). Can also include git_pkgs (list of lists) and pypi_pkgs (vector of strings, optionally with version "name@version") to install from Git or PyPI. If Python packages are requested but {reticulate} is not in the list of R packages, the user will be warned that they may want to add it. When py_conf packages are requested, the RETICULATE_PYTHON environment variable is set to ensure the Nix environment does not use a system-wide Python installation. If you are developing a Python package, set py_src_dir to the path of your package''s source directory (e.g., "mypackage/src" or just "src"). This adds PYTHONPATH to the shell hook so your package can be imported without installation. This is the Nix equivalent of pip install -e . (editable install). Note: if "uv" is in system_pkgs, LD_LIBRARY_PATH is automatically configured for dynamic library loading (required by packages like numpy). List. A list of two elements, jl_version and jl_conf. jl_version must be of the form "1.10" for Julia 1.10. Leave empty or use an empty string to use the latest version, or use "lts" for the long term support version. jl_conf must be an atomic vector of packages names, for example jl_conf = c("TidierData", "TidierPlots"). Character, defaults to "none". If you wish to use RStudio to work interactively use "rstudio" or "rserver" for the server version. Use "code" for Visual Studio Code or "codium" for Codium, or "positron" for Positron. You can also use "radian", an interactive REPL. This will install a project-specific version of the chosen editor which will be differrent than the one already present in your system (if any). For other editors or if you want to use an editor already installed on your system (which will require some configuration to make it work seamlessly with Nix shells see the vignette("configuring-ide") for configuration examples), use "none". Please be aware that VS Code and Positron are not free software. To facilitate their installation, rix() automatically enables a required setting without prompting the user for confirmation. See the "Details" section below for more information. Logical, defaults to FALSE. If TRUE, overwrite the default.nix file in the specified path. Logical, defaults to FALSE. If TRUE, print default.nix to console. Character. Message type, defaults to "simple", which gives minimal but sufficient feedback. Other values are currently "quiet, which generates the files without message, and "verbose", displays all the messages. Character of length 1, defaults to NULL. Commands added to the shellHook variable are executed when the Nix shell starts. So by default, using nix-shell default.nix will start a specific program, possibly with flags (separated by space), and/or do shell actions. You can for example use shell_hook = R, if you want to directly enter the declared Nix R session when dropping into the Nix shell.'
  method: Character, the method of generating a nix environment from an renv.lock file. "fast" is an inexact conversion which simply extracts the R version and a list of all the packages in an renv.lock file and adds them to the r_pkgs argument of rix(). This will use a snapshot of nixpkgs that should contain package versions that are not too different from the ones defined in the renv.lock file. For packages installed from GitHub or similar, an attempt is made to handle them and pass them to the git_pkgs argument of rix(). Currently defaults to "fast", "accurate" is not yet implemented.
  override_r_ver: Character, defaults to NULL, override the R version defined in the renv.lock file with another version. This is especially useful if the renv.lock file lists a version of R not (yet) available through Nix, or if the R version included in the renv.lock is too old compared to the package versions. Can also be a date, check available_dates().
  project_path: Character, where to write default.nix, for example "/home/path/to/project". The file will thus be written to the file "/home/path/to/project/default.nix". If the folder does not exist, it will be created.
  renv_lock_path: Character, path of the renv.lock file, defaults to "renv.lock"
  return_rix_call: Logical, return the generated rix function call instead of evaluating it this is for debugging purposes, defaults to FALSE
returns: Nothing, this function is called for its side effects only, unless return_rix_call = TRUE in which case an unevaluated call to rix() is returned
examples:
- code: |-
    renv2nix(
    renv_lock_path = "path/to/original/renv_project/renv.lock",
    project_path = "path/to/rix_project"
    )
- code: |-
    renv2nix(
    renv_lock_path = "path/to/rix_project/renv.lock",
    project_path = "path/to/rix_project"
    )
---
kind: function
name: available_df
exported: true
signature: available_df()
returns: A data frame
examples:
- code: available_dates()
---
kind: function
name: available_r
exported: true
signature: available_r()
returns: A character vector containing the available R versions.
examples:
- code: available_r()
---
kind: function
name: available_dates
exported: true
signature: available_dates()
returns: A character vector containing the available dates
examples:
- code: available_dates()
---
kind: function
name: ga_cachix
exported: true
signature: ga_cachix(cache_name, path_default)
arguments:
  cache_name: String, name of your cache.
  path_default: String, relative path (from the root directory of your project) to the default.nix to build.
returns: Nothing, copies file to a directory.
examples:
- code: ga_cachix("my-cachix", path_default = "default.nix")
---
kind: function
name: rix_init
exported: true
signature: rix_init(project_path,rprofile_action = c("create_missing","create_backup","overwrite","append"),message_type = c("simple", "quiet", "verbose")) {message_type <- match.arg(message_type,choices = c("simple", "quiet", "verbose"))is_quiet <- message_type == "quiet"rprofile_action <- match.arg(rprofile_action,choices = c("create_missing", "create_backup", "overwrite", "append"))stopifnot("`project_path` needs to be character of length 1" = is.character(project_path) &&length(project_path) == 1L)if (isFALSE(is_quiet) && identical(Sys.getenv("TESTTHAT"), "false"))
purpose: Initiate and maintain an isolated, project-specific, and runtime-pure R setup via Nix.
arguments:
  message_type: Character. Message type, defaults to "simple", which gives minimal but sufficient feedback. Other values are currently "quiet, which writes .Rprofile without message, and "verbose", which displays the mechanisms implemented to achieve fully controlled R project environments in Nix.
  project_path: Character with the folder path to the isolated nix-R project. If the folder does not exist yet, it will be created.
  rprofile_action: Character. Action to take with .Rprofile file destined for project_path folder. Possible values include "create_missing", which only writes .Rprofile if it does not yet exist (otherwise does nothing) - this is the action set when using rix() - ; "create_backup", which copies the existing .Rprofile to a new backup file, generating names with POSIXct-derived strings that include the time zone information. A new .Rprofile file will be written with default code from rix::rix_init(); "overwrite" overwrites the .Rprofile file if it does exist; "append" appends the existing file with code that is tailored to an isolated Nix-R project setup.
returns: Nothing, this function only has the side-effect of writing a file called ".Rprofile" to the specified path.
examples:
- code: project_path <- "./sub_shell"
- code: if (!dir.exists(project_path)) dir.create(project_path)
- code: |-
    rix_init(
    project_path = project_path,
    rprofile_action = "create_missing",
    message_type = c("simple")
    )
---
kind: function
name: with_nix
exported: true
signature: with_nix(expr,program = c("R", "shell"),project_path = ".",message_type = c("simple", "quiet", "verbose"))
arguments:
  expr: Single R function or call, or character vector of length one with shell command and possibly options (flags) of the command to be invoked. For program = R, you can both use a named or an anonymous function. The function provided in expr should not evaluate when you pass arguments, hence you need to wrap your function call like function() your_fun(arg_a = "a", arg_b = "b"), to avoid evaluation and make sure expr is a function (see details and examples).
  message_type: String how detailed output is. Currently, there is either "simple" (default), "quiet or "verbose", which shows the script that runs via nix-shell.
  program: String stating where to evaluate the expression. Either "R", the default, or "shell". where = "R" will evaluate the expression via RScript and where = "shell" will run the system command in nix-shell.
  project_path: Path to the folder where the default.nix file resides. The default is ".", which is the working directory in the current R session. This approach also useful when you have different subfolders with separate software environments defined in different default.nix files.
returns: 'if program = "R", R object returned by function given in expr when evaluated via the R environment in nix-shell defined by Nix expression. if program = "shell", list with the following elements: status: exit code stdout: character vector with standard output stderr: character vector with standard error of expr command sent to a command line interface provided by a Nix package.'
examples:
- code: project_path <- "./sub_shell"
- code: |-
    rix_init(
    project_path = project_path,
    rprofile_action = "create_missing"
    )
- code: |-
    rix(
    r_ver = "4.2.0",
    project_path = project_path
    )
---
kind: function
name: rix
exported: true
signature: rix(r_ver = NULL,date = NULL,r_pkgs = NULL,system_pkgs = NULL,git_pkgs = NULL,local_r_pkgs = NULL,tex_pkgs = NULL,py_conf = NULL,jl_conf = NULL,ide = "none",project_path,overwrite = FALSE,print = FALSE,message_type = "simple",shell_hook = NULL,ignore_remotes_cache = FALSE)
arguments:
  date: Character. Instead of providing r_ver, it is also possible to provide a date. This will build an environment containing R and R packages (and other dependencies) as of that date. You can check which dates are available with available_dates(). For more details about versions check available_df().
  git_pkgs: List. A list of packages to install from Git. See details for more information.
  ide: Character, defaults to "none". If you wish to use RStudio to work interactively use "rstudio" or "rserver" for the server version. Use "code" for Visual Studio Code or "codium" for Codium, or "positron" for Positron. You can also use "radian", an interactive REPL. This will install a project-specific version of the chosen editor which will be differrent than the one already present in your system (if any). For other editors or if you want to use an editor already installed on your system (which will require some configuration to make it work seamlessly with Nix shells see the vignette("configuring-ide") for configuration examples), use "none". Please be aware that VS Code and Positron are not free software. To facilitate their installation, rix() automatically enables a required setting without prompting the user for confirmation. See the "Details" section below for more information.
  ignore_remotes_cache: Logical, defaults to FALSE. This variable is only needed when adding packages from GitHub with remote dependencies, it can be ignored otherwise. If TRUE, the cache of already processed GitHub remotes will be ignored and all packages will be processed. If FALSE, the cache will be used to skip already processed packages, which makes use of fewer API calls. Setting this argument to TRUE can be useful for debugging.
  jl_conf: List. A list of two elements, jl_version and jl_conf. jl_version must be of the form "1.10" for Julia 1.10. Leave empty or use an empty string to use the latest version, or use "lts" for the long term support version. jl_conf must be an atomic vector of packages names, for example jl_conf = c("TidierData", "TidierPlots").
  local_r_pkgs: Vector of characters, paths to local packages to install. These packages need to be in the .tar.gz or .zip formats and must be in the same folder as the generated "default.nix" file.
  message_type: Character. Message type, defaults to "simple", which gives minimal but sufficient feedback. Other values are currently "quiet, which generates the files without message, and "verbose", displays all the messages.
  overwrite: Logical, defaults to FALSE. If TRUE, overwrite the default.nix file in the specified path.
  print: Logical, defaults to FALSE. If TRUE, print default.nix to console.
  project_path: Character, where to write default.nix, for example "/home/path/to/project". The file will thus be written to the file "/home/path/to/project/default.nix". If the folder does not exist, it will be created.
  py_conf: 'List. A list containing two or three elements: py_version, py_pkgs, and optionally py_src_dir. py_version should be in the form "3.12" for Python 3.12, and py_pkgs should be an atomic vector of package names (e.g., py_pkgs = c("polars", "plotnine", "great-tables")). Can also include git_pkgs (list of lists) and pypi_pkgs (vector of strings, optionally with version "name@version") to install from Git or PyPI. If Python packages are requested but {reticulate} is not in the list of R packages, the user will be warned that they may want to add it. When py_conf packages are requested, the RETICULATE_PYTHON environment variable is set to ensure the Nix environment does not use a system-wide Python installation. If you are developing a Python package, set py_src_dir to the path of your package''s source directory (e.g., "mypackage/src" or just "src"). This adds PYTHONPATH to the shell hook so your package can be imported without installation. This is the Nix equivalent of pip install -e . (editable install). Note: if "uv" is in system_pkgs, LD_LIBRARY_PATH is automatically configured for dynamic library loading (required by packages like numpy).'
  r_pkgs: Vector of characters. List the required R packages for your analysis here.
  r_ver: Character. The required R version, for example "4.0.0". You can check which R versions are available using available_r(), and for more details check available_df(). For reproducibility purposes, you can also provide a nixpkgs revision directly. For older versions of R, nix-build might fail with an error stating 'this derivation is not meant to be built'. In this case, simply drop into the shell with nix-shell instead of building it first. It is also possible to provide either "bleeding-edge" or "frozen-edge" if you need an environment with bleeding edge packages. Read more in the "Details" section below.
  shell_hook: Character of length 1, defaults to NULL. Commands added to the shellHook variable are executed when the Nix shell starts. So by default, using nix-shell default.nix will start a specific program, possibly with flags (separated by space), and/or do shell actions. You can for example use shell_hook = R, if you want to directly enter the declared Nix R session when dropping into the Nix shell.
  system_pkgs: Vector of characters. List further software you wish to install that are not R packages such as command line applications for example. You can look for available software on the NixOS website https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=
  tex_pkgs: Vector of characters. A set of TeX packages to install. Use this if you need to compile .tex documents, or build PDF documents using Quarto. If you don't know which package to add, start by adding "amsmath". See the vignette("d2- installing-system-tools-and-texlive-packages-in-a-nix-environment") for more details.
returns: 'Nothing, this function only has the side-effect of writing two files: default.nix and .Rprofile in the working directory. default.nix contains a Nix expression to build a reproducible environment using the Nix package manager, and .Rprofile ensures that a running R session from a Nix environment cannot access local libraries, nor install packages using install.packages() (nor remove nor update them).'
examples:
- code: |-
    rix(
    r_ver = "latest-upstream",
    r_pkgs = c("dplyr", "ggplot2"),
    system_pkgs = NULL,
    git_pkgs = NULL,
    local_r_pkgs = NULL,
    ide = "code",
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE,
    message_type = "simple",
    shell_hook = NULL,
    ignore_remotes_cache = FALSE
    )
---
kind: function
name: make_launcher
exported: true
signature: make_launcher(editor, project_path)
arguments:
  editor: Character, the command to launch the editor. See the "Details" section below for more information.
  project_path: Character, where to write the launcher, for example "/home/path/to/project". The file will thus be written to the file "/home/path/to/project/start-editor.sh". If the folder does not exist, it will be created.
returns: Nothing, writes a script.
examples:
- code: available_dates()
---
kind: function
name: nix_build
exported: true
signature: nix_build(project_path = getwd(),message_type = c("simple", "quiet", "verbose"),args = NULL)
arguments:
  args: A character vector of additional arguments to be passed directly to the nix-build command. If the project directory (i.e. project_path) is not included in args, it will be appended automatically.
  message_type: Character vector with messaging type. Either "simple" (default), "quiet" for no messaging, or "verbose".
  project_path: Path to the folder where the default.nix file resides.
returns: Integer of the process ID (PID) of the nix-build shell command launched, if the nix_build() call is assigned to an R object. Otherwise, it will be returned invisibly.
examples:
- code: nix_build()
- code: nix_build(args = c("--max-jobs", "2", "--quiet"))
---
kind: function
name: setup_cachix
exported: true
signature: setup_cachix(nix_conf_path = "~/.config/nix")
arguments:
  nix_conf_path: Character, path to folder containing 'nix.conf' file. Defaults to "~/.config/nix".
returns: Nothing; changes a file in the user's home directory.
examples:
- code: setup_cachix()
---
kind: function
name: tar_nix_ga
exported: true
signature: tar_nix_ga()
returns: Nothing, copies file to a directory.
examples:
- code: tar_nix_ga()
